---
description: Rules on Forms
globs:
alwaysApply: true
---

# Handling Forms

- Always use NextJS `<Form />` component, instead of the native HTML `<form />`
- Make sure to set the form autoComplete to off
- If a page needs a form, separate the form as a separated component from the page. Keep the `page.tsx` as a server side component
- The form component should obviously be a client component. Mark them with `use client`
- Leverage the React's `useActionState` hook to handle form state and errors.
- I need you think thoroughly about the `initialState` that should be fed into the `useActionState` hook. It should be tailored to the specific needs of the form.
- I want you to always include `{ message: string | null, errors: SpecificFormErrorType, defaultValue, axiosError?: { status: number, errors: Record<string, string[]>} }`
- You should use this guide for any complex form, such as category creation and update.
- Simple forms like OTP challenge and search form do not need this approach.

## Actions

Server actions to handle form as explained on [https://nextjs.org/docs/app/guides/forms](https://nextjs.org/docs/app/guides/forms). I need you to create a dedicated server action to handle each form.

- Remember to create the actions inside their respective directory. Preferably in the `src/actions`
- Server actions for student should be kept in the `src/actions/student`
- Server actions for admin should be kept in the `src/actions/admin`
- Each server action files should contain the validation schema for the form data, type definition for the form state (remember that we are going to use `useActionState`), and the server action function itself.
- You need to carefully think about the schema that should be applied on each field. Use `zod` to create the form schema
- Export the type definitions and the server action function. The validation schema should be okay to be left unexported.
- The server action function should
  - validate the form data with `zod`
  - if validation is not succeeded return the `{ message, errors, defaultValue }`. This `defaultValue` would be used for the form to prevent field values from being wiped upon form submission.
  - If validation is succeeded call the specific POST endpoint using  the `axiosServer` instance.
  - After a successful POST submission, do `revalidatePath` and `redirect` to the approriate page

## FormState Type Reference

```typescript
export type FormState = {
  errors?: {    // tailor this `errors` object to the form, no form would have the same error buckets
    customerId?: string[];
    amount?: string[];
    status?: string[];
  };
  message?: string | null;
};
```
